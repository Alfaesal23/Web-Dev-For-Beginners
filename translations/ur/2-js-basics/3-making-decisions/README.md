<!--
CO_OP_TRANSLATOR_METADATA:
{
  "original_hash": "90a3c32c3377f83ab750c2447c77ab98",
  "translation_date": "2025-10-22T14:33:51+00:00",
  "source_file": "2-js-basics/3-making-decisions/README.md",
  "language_code": "ur"
}
-->
# جاوا اسکرپٹ کی بنیادی باتیں: فیصلے کرنا

![جاوا اسکرپٹ کی بنیادی باتیں - فیصلے کرنا](../../../../translated_images/webdev101-js-decisions.69e1b20f272dd1f0b1cb2f8adaff3ed2a77c4f91db96d8a0594132a353fa189a.ur.png)

> اسکیچ نوٹ [Tomomi Imura](https://twitter.com/girlie_mac) کی جانب سے

کیا آپ نے کبھی سوچا ہے کہ ایپلیکیشنز کیسے سمجھدار فیصلے کرتی ہیں؟ جیسے کہ نیویگیشن سسٹم تیز ترین راستہ کیسے منتخب کرتا ہے، یا تھرمو اسٹیٹ کب ہیٹ آن کرے گا؟ یہ پروگرامنگ میں فیصلے کرنے کا بنیادی تصور ہے۔

جیسے کہ چارلس بیبیج کے اینالیٹیکل انجن کو مختلف حالات کے تحت مختلف آپریشنز کے سیکوینسز کو فالو کرنے کے لیے ڈیزائن کیا گیا تھا، جدید جاوا اسکرپٹ پروگرامز کو مختلف حالات کے تحت انتخاب کرنے کی ضرورت ہوتی ہے۔ یہ صلاحیت کہ کوڈ کو مختلف راستوں پر لے جایا جا سکے، جامد کوڈ کو جوابدہ اور ذہین ایپلیکیشنز میں تبدیل کرتی ہے۔

اس سبق میں، آپ اپنے پروگرامز میں کنڈیشنل لاجک کو نافذ کرنے کا طریقہ سیکھیں گے۔ ہم کنڈیشنل اسٹیٹمنٹس، کمپیریزن آپریٹرز، اور لاجیکل ایکسپریشنز کا جائزہ لیں گے جو آپ کے کوڈ کو حالات کا جائزہ لینے اور مناسب ردعمل دینے کی اجازت دیتے ہیں۔

## لیکچر سے پہلے کا کوئز

[لیکچر سے پہلے کا کوئز](https://ff-quizzes.netlify.app/web/quiz/11)

فیصلے کرنے اور پروگرام کے بہاؤ کو کنٹرول کرنے کی صلاحیت پروگرامنگ کا ایک بنیادی پہلو ہے۔ اس سیکشن میں ہم جاوا اسکرپٹ پروگرامز کے ایگزیکیوشن راستے کو Boolean ویلیوز اور کنڈیشنل لاجک کے ذریعے کنٹرول کرنے کا طریقہ سیکھیں گے۔

[![فیصلے کرنا](https://img.youtube.com/vi/SxTp8j-fMMY/0.jpg)](https://youtube.com/watch?v=SxTp8j-fMMY "فیصلے کرنا")

> 🎥 اوپر دی گئی تصویر پر کلک کریں فیصلے کرنے کے بارے میں ویڈیو دیکھنے کے لیے۔

> آپ یہ سبق [Microsoft Learn](https://docs.microsoft.com/learn/modules/web-development-101-if-else/?WT.mc_id=academic-77807-sagibbon) پر لے سکتے ہیں!

## Boolean پر مختصر نظر

فیصلے کرنے سے پہلے، آئیے پچھلے سبق سے Boolean ویلیوز پر نظر ڈالیں۔ یہ ویلیوز، جو ریاضی دان جارج بول کے نام پر ہیں، دو حالتوں کی نمائندگی کرتی ہیں – `true` یا `false`۔ کوئی ابہام نہیں، کوئی درمیانی راستہ نہیں۔

یہ بائنری ویلیوز تمام کمپیوٹیشنل لاجک کی بنیاد ہیں۔ آپ کے پروگرام کا ہر فیصلہ بالآخر Boolean ایویلیوایشن پر آتا ہے۔

Boolean ویریبلز بنانا آسان ہے:

```javascript
let myTrueBool = true;
let myFalseBool = false;
```

یہ دو ویریبلز کو واضح Boolean ویلیوز کے ساتھ بناتا ہے۔

✅ Boolean ویلیوز کا نام انگریزی ریاضی دان، فلسفی اور منطقی جارج بول (1815–1864) کے نام پر رکھا گیا ہے۔

## کمپیریزن آپریٹرز اور Boolean

عملی طور پر، آپ شاذ و نادر ہی Boolean ویلیوز کو دستی طور پر سیٹ کریں گے۔ اس کے بجائے، آپ حالات کا جائزہ لے کر انہیں جنریٹ کریں گے: "کیا یہ نمبر اس سے بڑا ہے؟" یا "کیا یہ ویلیوز برابر ہیں؟"

کمپیریزن آپریٹرز ان جائزوں کو ممکن بناتے ہیں۔ یہ ویلیوز کا موازنہ کرتے ہیں اور Boolean نتائج واپس کرتے ہیں جو آپریندز کے درمیان تعلق پر مبنی ہوتے ہیں۔

| علامت | وضاحت                                                                                                                                                   | مثال            |
| ------ | ------------------------------------------------------------------------------------------------------------------------------------------------------------- | ------------------ |
| `<`    | **کم سے کم**: دو ویلیوز کا موازنہ کرتا ہے اور `true` Boolean ڈیٹا ٹائپ واپس کرتا ہے اگر بائیں طرف کی ویلیو دائیں طرف سے کم ہو                              | `5 < 6 // true`    |
| `<=`   | **کم یا برابر**: دو ویلیوز کا موازنہ کرتا ہے اور `true` Boolean ڈیٹا ٹائپ واپس کرتا ہے اگر بائیں طرف کی ویلیو دائیں طرف سے کم یا برابر ہو      | `5 <= 6 // true`   |
| `>`    | **زیادہ**: دو ویلیوز کا موازنہ کرتا ہے اور `true` Boolean ڈیٹا ٹائپ واپس کرتا ہے اگر بائیں طرف کی ویلیو دائیں طرف سے زیادہ ہو                         | `5 > 6 // false`   |
| `>=`   | **زیادہ یا برابر**: دو ویلیوز کا موازنہ کرتا ہے اور `true` Boolean ڈیٹا ٹائپ واپس کرتا ہے اگر بائیں طرف کی ویلیو دائیں طرف سے زیادہ یا برابر ہو | `5 >= 6 // false`  |
| `===`  | **سخت برابری**: دو ویلیوز کا موازنہ کرتا ہے اور `true` Boolean ڈیٹا ٹائپ واپس کرتا ہے اگر بائیں اور دائیں ویلیوز برابر ہوں اور ایک ہی ڈیٹا ٹائپ ہوں۔       | `5 === 6 // false` |
| `!==`  | **عدم برابری**: دو ویلیوز کا موازنہ کرتا ہے اور سخت برابری آپریٹر کے برعکس Boolean ویلیو واپس کرتا ہے                                    | `5 !== 6 // true`  |

✅ اپنے علم کو چیک کریں اور کچھ موازنہ اپنے براؤزر کے کنسول میں لکھیں۔ کیا کوئی واپس شدہ ڈیٹا آپ کو حیران کرتا ہے؟

## If اسٹیٹمنٹ

`if` اسٹیٹمنٹ آپ کے کوڈ میں سوال پوچھنے جیسا ہے۔ "اگر یہ حالت درست ہے، تو یہ کام کرو۔" یہ شاید جاوا اسکرپٹ میں فیصلے کرنے کے لیے سب سے اہم ٹول ہے۔

یہ اس طرح کام کرتا ہے:

```javascript
if (condition) {
  // Condition is true. Code in this block will run.
}
```

حالت کو قوسین کے اندر رکھا جاتا ہے، اور اگر یہ `true` ہو، تو جاوا اسکرپٹ کوڈ کو کرلی بریکٹس کے اندر چلاتا ہے۔ اگر یہ `false` ہو، تو جاوا اسکرپٹ اس پورے بلاک کو چھوڑ دیتا ہے۔

آپ اکثر کمپیریزن آپریٹرز کا استعمال کرتے ہوئے ان حالات کو بنائیں گے۔ آئیے ایک عملی مثال دیکھتے ہیں:

```javascript
let currentMoney = 1000;
let laptopPrice = 800;

if (currentMoney >= laptopPrice) {
  // Condition is true. Code in this block will run.
  console.log("Getting a new laptop!");
}
```

چونکہ `1000 >= 800` کا نتیجہ `true` ہے، بلاک کے اندر کا کوڈ چلتا ہے، اور کنسول میں "Getting a new laptop!" ظاہر ہوتا ہے۔

## If..Else اسٹیٹمنٹ

لیکن اگر آپ چاہتے ہیں کہ آپ کا پروگرام حالت کے غلط ہونے پر کچھ مختلف کرے؟ یہی وہ جگہ ہے جہاں `else` آتا ہے – یہ جیسے ایک بیک اپ پلان ہے۔

`else` اسٹیٹمنٹ آپ کو یہ کہنے کا طریقہ دیتا ہے "اگر یہ حالت درست نہیں ہے، تو یہ دوسرا کام کرو۔"

```javascript
let currentMoney = 500;
let laptopPrice = 800;

if (currentMoney >= laptopPrice) {
  // Condition is true. Code in this block will run.
  console.log("Getting a new laptop!");
} else {
  // Condition is false. Code in this block will run.
  console.log("Can't afford a new laptop, yet!");
}
```

اب چونکہ `500 >= 800` `false` ہے، جاوا اسکرپٹ پہلے بلاک کو چھوڑ دیتا ہے اور `else` بلاک کو چلاتا ہے۔ آپ کنسول میں "Can't afford a new laptop, yet!" دیکھیں گے۔

✅ اس کوڈ اور نیچے دیے گئے کوڈ کو براؤزر کنسول میں چلا کر اپنی سمجھ کو جانچیں۔ currentMoney اور laptopPrice ویریبلز کی ویلیوز کو تبدیل کریں تاکہ واپس شدہ `console.log()` کو تبدیل کیا جا سکے۔

## Switch اسٹیٹمنٹ

کبھی کبھار آپ کو ایک ویلیو کو کئی آپشنز کے خلاف موازنہ کرنے کی ضرورت ہوتی ہے۔ حالانکہ آپ کئی `if..else` اسٹیٹمنٹس کو چین کر سکتے ہیں، یہ طریقہ غیر عملی ہو جاتا ہے۔ `switch` اسٹیٹمنٹ متعدد واضح ویلیوز کو ہینڈل کرنے کے لیے ایک صاف ستھرا ڈھانچہ فراہم کرتا ہے۔

یہ تصور ابتدائی ٹیلیفون ایکسچینجز میں استعمال ہونے والے میکینیکل سوئچنگ سسٹمز سے مشابہت رکھتا ہے – ایک ان پٹ ویلیو یہ طے کرتی ہے کہ ایگزیکیوشن کس مخصوص راستے پر جائے گا۔

```javascript
switch (expression) {
  case x:
    // code block
    break;
  case y:
    // code block
    break;
  default:
    // code block
}
```

یہاں اس کا ڈھانچہ ہے:
- جاوا اسکرپٹ ایکسپریشن کو ایک بار ایویلیوایٹ کرتا ہے
- ہر `case` کو دیکھتا ہے تاکہ میچ تلاش کرے
- جب میچ ملتا ہے، تو وہ کوڈ بلاک چلاتا ہے
- `break` جاوا اسکرپٹ کو سوئچ سے باہر نکلنے کا کہتا ہے
- اگر کوئی کیس میچ نہ کرے، تو وہ `default` بلاک چلاتا ہے (اگر آپ کے پاس ہو)

```javascript
// Program using switch statement for day of week
let dayNumber = 2;
let dayName;

switch (dayNumber) {
  case 1:
    dayName = "Monday";
    break;
  case 2:
    dayName = "Tuesday";
    break;
  case 3:
    dayName = "Wednesday";
    break;
  default:
    dayName = "Unknown day";
    break;
}
console.log(`Today is ${dayName}`);
```

اس مثال میں، جاوا اسکرپٹ دیکھتا ہے کہ `dayNumber` `2` ہے، میچنگ `case 2` کو تلاش کرتا ہے، `dayName` کو "Tuesday" پر سیٹ کرتا ہے، اور پھر سوئچ سے باہر نکلتا ہے۔ نتیجہ؟ "Today is Tuesday" کنسول میں ظاہر ہوتا ہے۔

✅ اس کوڈ اور نیچے دیے گئے کوڈ کو براؤزر کنسول میں چلا کر اپنی سمجھ کو جانچیں۔ ویریبل a کی ویلیوز کو تبدیل کریں تاکہ واپس شدہ `console.log()` کو تبدیل کیا جا سکے۔

## لاجیکل آپریٹرز اور Boolean

پیچیدہ فیصلے اکثر ایک ساتھ کئی حالات کا جائزہ لینے کی ضرورت ہوتی ہے۔ جیسے کہ Boolean الجبرا ریاضی دانوں کو لاجیکل ایکسپریشنز کو جوڑنے کی اجازت دیتا ہے، پروگرامنگ لاجیکل آپریٹرز فراہم کرتی ہے تاکہ کئی Boolean حالات کو جوڑا جا سکے۔

یہ آپریٹرز سادہ true/false جائزوں کو جوڑ کر پیچیدہ کنڈیشنل لاجک کو ممکن بناتے ہیں۔

| علامت | وضاحت                                                                                     | مثال                                                                 |
| ------ | ----------------------------------------------------------------------------------------------- | ----------------------------------------------------------------------- |
| `&&`   | **لاجیکل AND**: دو Boolean ایکسپریشنز کا موازنہ کرتا ہے۔ صرف اس وقت true واپس کرتا ہے جب دونوں طرف true ہوں | `(5 > 3) && (5 < 10) // دونوں طرف true ہیں۔ true واپس کرتا ہے` |
| `\|\|` | **لاجیکل OR**: دو Boolean ایکسپریشنز کا موازنہ کرتا ہے۔ اگر کم از کم ایک طرف true ہو تو true واپس کرتا ہے     | `(5 > 10) \|\| (5 < 10) // ایک طرف false ہے، دوسری true ہے۔ true واپس کرتا ہے` |
| `!`    | **لاجیکل NOT**: Boolean ایکسپریشن کی مخالف ویلیو واپس کرتا ہے                             | `!(5 > 10) // 5 10 سے زیادہ نہیں ہے، تو "!" اسے true بناتا ہے`         |

یہ آپریٹرز آپ کو حالات کو مفید طریقوں سے جوڑنے دیتے ہیں:
- AND (`&&`) کا مطلب ہے دونوں حالات true ہونے چاہئیں
- OR (`||`) کا مطلب ہے کم از کم ایک حالت true ہونی چاہیے  
- NOT (`!`) true کو false میں تبدیل کرتا ہے (اور اس کے برعکس)

## لاجیکل آپریٹرز کے ساتھ حالات اور فیصلے

آئیے ان لاجیکل آپریٹرز کو ایک زیادہ حقیقت پسندانہ مثال کے ساتھ دیکھتے ہیں:

```javascript
let currentMoney = 600;
let laptopPrice = 800;
let laptopDiscountPrice = laptopPrice - (laptopPrice * 0.2); // Laptop price at 20 percent off

if (currentMoney >= laptopPrice || currentMoney >= laptopDiscountPrice) {
  // Condition is true. Code in this block will run.
  console.log("Getting a new laptop!");
} else {
  // Condition is false. Code in this block will run.
  console.log("Can't afford a new laptop, yet!");
}
```

اس مثال میں: ہم 20% ڈسکاؤنٹ قیمت (640) کا حساب لگاتے ہیں، پھر جائزہ لیتے ہیں کہ آیا ہمارے دستیاب فنڈز مکمل قیمت یا ڈسکاؤنٹ قیمت کو پورا کرتے ہیں۔ چونکہ 600 ڈسکاؤنٹ قیمت کی حد 640 کو پورا کرتا ہے، حالت true میں ایویلیوایٹ ہوتی ہے۔

### نیگیشن آپریٹر

کبھی کبھار یہ آسان ہوتا ہے کہ جب کچھ true نہ ہو تو اس کے بارے میں سوچا جائے۔ جیسے کہ "کیا یوزر لاگ ان ہے؟" پوچھنے کے بجائے، آپ "کیا یوزر لاگ ان نہیں ہے؟" پوچھنا چاہیں گے۔ ایکسکلیمیشن مارک (`!`) آپ کے لیے لاجک کو پلٹ دیتا ہے۔

```javascript
if (!condition) {
  // runs if condition is false
} else {
  // runs if condition is true
}
```

`!` آپریٹر یہ کہنے جیسا ہے "اس کے برعکس..." – اگر کچھ `true` ہے، `!` اسے `false` بناتا ہے، اور اس کے برعکس۔

### ٹرنری ایکسپریشنز

سادہ کنڈیشنل اسائنمنٹس کے لیے، جاوا اسکرپٹ **ٹرنری آپریٹر** فراہم کرتا ہے۔ یہ مختصر سینٹیکس آپ کو ایک کنڈیشنل ایکسپریشن کو ایک لائن میں لکھنے کی اجازت دیتا ہے، جو اس وقت مفید ہوتا ہے جب آپ کو کسی حالت کی بنیاد پر دو ویلیوز میں سے ایک کو اسائن کرنا ہو۔

```javascript
let variable = condition ? returnThisIfTrue : returnThisIfFalse;
```

یہ ایک سوال کی طرح پڑھتا ہے: "کیا یہ حالت true ہے؟ اگر ہاں، تو یہ ویلیو استعمال کریں۔ اگر نہیں، تو وہ ویلیو استعمال کریں۔"

نیچے ایک زیادہ قابل فہم مثال ہے:

```javascript
let firstNumber = 20;
let secondNumber = 10;
let biggestNumber = firstNumber > secondNumber ? firstNumber : secondNumber;
```

✅ اس کوڈ کو چند بار پڑھنے کے لیے ایک منٹ نکالیں۔ کیا آپ سمجھتے ہیں کہ یہ آپریٹرز کیسے کام کر رہے ہیں؟

یہ لائن یہ کہہ رہی ہے: "کیا `firstNumber` `secondNumber` سے بڑا ہے؟ اگر ہاں، تو `firstNumber` کو `biggestNumber` میں ڈالیں۔ اگر نہیں، تو `secondNumber` کو `biggestNumber` میں ڈالیں۔"

ٹرنری آپریٹر یہ روایتی `if..else` اسٹیٹمنٹ لکھنے کا صرف ایک مختصر طریقہ ہے:

```javascript
let biggestNumber;
if (firstNumber > secondNumber) {
  biggestNumber = firstNumber;
} else {
  biggestNumber = secondNumber;
}
```

دونوں طریقے ایک جیسے نتائج پیدا کرتے ہیں۔ ٹرنری آپریٹر اختصار فراہم کرتا ہے، جبکہ روایتی if-else ڈھانچہ پیچیدہ حالات کے لیے زیادہ قابل مطالعہ ہو سکتا ہے۔

---

## 🚀 چیلنج

ایک پروگرام بنائیں جو پہلے لاجیکل آپریٹرز کے ساتھ لکھا گیا ہو، اور پھر اسے ٹرنری ایکسپریشن کا استعمال کرتے ہوئے دوبارہ لکھیں۔ آپ کو کون سا سینٹیکس پسند ہے؟

---

## GitHub Copilot ایجنٹ چیلنج 🚀

ایجنٹ موڈ کا استعمال کرتے ہوئے درج ذیل چیلنج مکمل کریں:

**تفصیل:** ایک جامع گریڈ کیلکولیٹر بنائیں جو اس سبق سے متعدد فیصلے کرنے کے تصورات کو ظاہر کرے، بشمول if-else اسٹیٹمنٹس، switch اسٹیٹمنٹس، لاجیکل آپریٹرز، اور ٹرنری ایکسپریشنز۔

**پرومپٹ:** ایک جاوا اسکرپٹ پروگرام لکھیں جو طالب علم کے عددی اسکور (0-100) کو لے اور درج ذیل معیار کے مطابق ان کے لیٹر گریڈ کا تعین کرے:
- A: 90-100
- B: 80-89  
- C: 70-79
- D: 60-69
- F: 60 سے کم

ضروریات:
1. لیٹر گریڈ کا تعین کرنے کے لیے if-else اسٹیٹمنٹ کا استعمال کریں
2. چیک کرنے کے لیے لاجیکل آپریٹرز کا استعمال کریں کہ آیا طالب علم پاس کرتا ہے (گریڈ >= 60) اور آنرز حاصل کرتا ہے (گریڈ >= 90)
3. ہر لیٹر گریڈ کے لیے مخصوص فیڈبیک فراہم کرنے کے لیے switch اسٹیٹمنٹ کا استعمال کریں
4. اگلے کورس کے لیے اہل ہونے کا تعین کرنے کے لیے ٹرنری آپریٹر کا استعمال کریں (گریڈ >= 70)
5. اسکور کو 0 اور 100 کے درمیان یقینی بنانے کے لیے ان پٹ ویلیڈیشن شامل کریں

اپنے پروگرام کو مختلف اسکورز کے ساتھ ٹیسٹ کریں، بشمول کنارے کے کیسز جیسے 59، 60، 89، 90، اور غیر درست ان پٹس۔

[ایجنٹ موڈ](https://code.visualstudio.com/blogs/2025/02/24/introducing-copilot-agent-mode) کے بارے میں مزید جانیں۔

## لیکچر کے بعد کا کوئز

[لیکچر کے بعد کا کوئز](https://ff-quizzes.netlify.app/web/quiz/12)

## جائزہ اور خود مطالعہ

صارف کے لیے دستیاب متعدد آپریٹرز کے بارے میں مزید پڑھیں [MDN پر](https://developer.mozilla.org/docs/Web/JavaScript/Reference/Operators)۔

جوش کومو کے شاندار [آپریٹر لوک اپ](https://joshwcomeau.com/operator-lookup/) کو دیکھیں!

## اسائنمنٹ

[آپریٹرز](assignment.md)

---

**اعلانِ لاتعلقی**:  
یہ دستاویز AI ترجمہ سروس [Co-op Translator](https://github.com/Azure/co-op-translator) کا استعمال کرتے ہوئے ترجمہ کی گئی ہے۔ ہم درستگی کے لیے کوشش کرتے ہیں، لیکن براہ کرم آگاہ رہیں کہ خودکار ترجمے میں غلطیاں یا غیر درستیاں ہو سکتی ہیں۔ اصل دستاویز کو اس کی اصل زبان میں مستند ذریعہ سمجھا جانا چاہیے۔ اہم معلومات کے لیے، پیشہ ور انسانی ترجمہ کی سفارش کی جاتی ہے۔ ہم اس ترجمے کے استعمال سے پیدا ہونے والی کسی بھی غلط فہمی یا غلط تشریح کے ذمہ دار نہیں ہیں۔