<!--
CO_OP_TRANSLATOR_METADATA:
{
  "original_hash": "90a3c32c3377f83ab750c2447c77ab98",
  "translation_date": "2025-10-23T01:11:41+00:00",
  "source_file": "2-js-basics/3-making-decisions/README.md",
  "language_code": "he"
}
-->
# יסודות JavaScript: קבלת החלטות

![JavaScript Basics - Making decisions](../../../../translated_images/webdev101-js-decisions.69e1b20f272dd1f0b1cb2f8adaff3ed2a77c4f91db96d8a0594132a353fa189a.he.png)

> סקצ'נוט מאת [Tomomi Imura](https://twitter.com/girlie_mac)

האם אי פעם תהיתם איך אפליקציות מקבלות החלטות חכמות? כמו איך מערכת ניווט בוחרת את המסלול המהיר ביותר, או איך תרמוסטט מחליט מתי להפעיל את החימום? זהו הרעיון הבסיסי של קבלת החלטות בתכנות.

כמו שמנוע האנליטי של צ'ארלס בבאג' תוכנן לבצע רצפים שונים של פעולות בהתבסס על תנאים, גם תוכניות מודרניות ב-JavaScript צריכות לקבל החלטות בהתבסס על נסיבות משתנות. היכולת הזו להתפצל ולקבל החלטות היא מה שהופך קוד סטטי לאפליקציות רספונסיביות ואינטליגנטיות.

בשיעור הזה תלמדו איך ליישם לוגיקה מותנית בתוכניות שלכם. נחקור הצהרות מותנות, אופרטורים להשוואה וביטויים לוגיים שמאפשרים לקוד שלכם להעריך מצבים ולהגיב בהתאם.

## שאלון לפני השיעור

[שאלון לפני השיעור](https://ff-quizzes.netlify.app/web/quiz/11)

היכולת לקבל החלטות ולשלוט בזרימת התוכנית היא היבט בסיסי בתכנות. חלק זה מכסה כיצד לשלוט בנתיב הביצוע של תוכניות JavaScript שלכם באמצעות ערכים בוליאניים ולוגיקה מותנית.

[![Making Decisions](https://img.youtube.com/vi/SxTp8j-fMMY/0.jpg)](https://youtube.com/watch?v=SxTp8j-fMMY "Making Decisions")

> 🎥 לחצו על התמונה למעלה לצפייה בסרטון על קבלת החלטות.

> ניתן ללמוד את השיעור הזה ב-[Microsoft Learn](https://docs.microsoft.com/learn/modules/web-development-101-if-else/?WT.mc_id=academic-77807-sagibbon)!

## סקירה קצרה על בוליאנים

לפני שנחקור את נושא קבלת ההחלטות, בואו נחזור לערכי בוליאן מהשיעור הקודם. ערכים אלו, שנקראו על שם המתמטיקאי ג'ורג' בול, מייצגים מצבים בינאריים – או `true` או `false`. אין עמימות, אין מצב ביניים.

ערכים בינאריים אלו מהווים את הבסיס לכל הלוגיקה החישובית. כל החלטה שהתוכנית שלכם מקבלת בסופו של דבר מתמצה להערכה בוליאנית.

יצירת משתנים בוליאניים היא פשוטה:

```javascript
let myTrueBool = true;
let myFalseBool = false;
```

זה יוצר שני משתנים עם ערכים בוליאניים מפורשים.

✅ בוליאנים נקראים על שם המתמטיקאי, הפילוסוף והלוגיקן האנגלי ג'ורג' בול (1815–1864).

## אופרטורים להשוואה ובוליאנים

בפועל, לעיתים רחוקות תגדירו ערכים בוליאניים באופן ידני. במקום זאת, תייצרו אותם על ידי הערכת תנאים: "האם המספר הזה גדול מהאחר?" או "האם הערכים הללו שווים?"

אופרטורים להשוואה מאפשרים את ההערכות הללו. הם משווים ערכים ומחזירים תוצאות בוליאניות בהתבסס על היחס בין האופרנדים.

| סימן | תיאור                                                                                                                                                   | דוגמה              |
| ------ | ------------------------------------------------------------------------------------------------------------------------------------------------------------- | ------------------ |
| `<`    | **קטן מ**: משווה שני ערכים ומחזיר את סוג הנתונים הבוליאני `true` אם הערך בצד שמאל קטן מהערך בצד ימין                              | `5 < 6 // true`    |
| `<=`   | **קטן או שווה ל**: משווה שני ערכים ומחזיר את סוג הנתונים הבוליאני `true` אם הערך בצד שמאל קטן או שווה לערך בצד ימין      | `5 <= 6 // true`   |
| `>`    | **גדול מ**: משווה שני ערכים ומחזיר את סוג הנתונים הבוליאני `true` אם הערך בצד שמאל גדול מהערך בצד ימין                         | `5 > 6 // false`   |
| `>=`   | **גדול או שווה ל**: משווה שני ערכים ומחזיר את סוג הנתונים הבוליאני `true` אם הערך בצד שמאל גדול או שווה לערך בצד ימין | `5 >= 6 // false`  |
| `===`  | **שוויון מוחלט**: משווה שני ערכים ומחזיר את סוג הנתונים הבוליאני `true` אם הערכים בצד ימין ושמאל שווים וגם מאותו סוג.       | `5 === 6 // false` |
| `!==`  | **אי שוויון**: משווה שני ערכים ומחזיר את הערך הבוליאני ההפוך ממה שאופרטור השוויון המוחלט היה מחזיר                                    | `5 !== 6 // true`  |

✅ בדקו את הידע שלכם על ידי כתיבת כמה השוואות בקונסול של הדפדפן שלכם. האם הנתונים שהוחזרו הפתיעו אתכם?

## הצהרת If

הצהרת `if` היא כמו לשאול שאלה בקוד שלכם. "אם התנאי הזה נכון, אז תעשה את הדבר הזה." זה כנראה הכלי החשוב ביותר שתשתמשו בו לקבלת החלטות ב-JavaScript.

כך זה עובד:

```javascript
if (condition) {
  // Condition is true. Code in this block will run.
}
```

התנאי נכנס בתוך הסוגריים, ואם הוא `true`, JavaScript מריץ את הקוד בתוך הסוגריים המסולסלים. אם הוא `false`, JavaScript פשוט מדלג על כל הבלוק הזה.

לעיתים קרובות תשתמשו באופרטורים להשוואה כדי ליצור את התנאים הללו. בואו נראה דוגמה מעשית:

```javascript
let currentMoney = 1000;
let laptopPrice = 800;

if (currentMoney >= laptopPrice) {
  // Condition is true. Code in this block will run.
  console.log("Getting a new laptop!");
}
```

מכיוון ש-`1000 >= 800` מוערך כ-`true`, הקוד בתוך הבלוק מתבצע ומציג "קונה מחשב נייד חדש!" בקונסול.

## הצהרת If..Else

אבל מה אם אתם רוצים שהתוכנית שלכם תעשה משהו אחר כשהתנאי הוא שגוי? כאן נכנס לתמונה `else` – זה כמו תוכנית גיבוי.

הצהרת `else` נותנת לכם דרך לומר "אם התנאי הזה לא נכון, תעשה את הדבר האחר במקום."

```javascript
let currentMoney = 500;
let laptopPrice = 800;

if (currentMoney >= laptopPrice) {
  // Condition is true. Code in this block will run.
  console.log("Getting a new laptop!");
} else {
  // Condition is false. Code in this block will run.
  console.log("Can't afford a new laptop, yet!");
}
```

עכשיו, מכיוון ש-`500 >= 800` הוא `false`, JavaScript מדלג על הבלוק הראשון ומריץ את בלוק ה-`else` במקום. תראו "עדיין לא יכול להרשות לעצמי מחשב נייד חדש!" בקונסול.

✅ בדקו את ההבנה שלכם לגבי הקוד הזה והקוד הבא על ידי הרצתם בקונסול של הדפדפן. שנו את הערכים של המשתנים currentMoney ו-laptopPrice כדי לשנות את התוצאה של `console.log()`.

## הצהרת Switch

לפעמים אתם צריכים להשוות ערך אחד מול מספר אפשרויות. למרות שתוכלו לשרשר מספר הצהרות `if..else`, הגישה הזו הופכת למסורבלת. הצהרת `switch` מספקת מבנה נקי יותר לטיפול בערכים דיסקרטיים מרובים.

הרעיון דומה למערכות מיתוג מכניות שהיו בשימוש במרכזיות טלפון מוקדמות – ערך קלט אחד קובע איזה נתיב ספציפי הביצוע יעקוב אחריו.

```javascript
switch (expression) {
  case x:
    // code block
    break;
  case y:
    // code block
    break;
  default:
    // code block
}
```

כך זה בנוי:
- JavaScript מעריך את הביטוי פעם אחת
- הוא עובר על כל `case` כדי למצוא התאמה
- כשהוא מוצא התאמה, הוא מריץ את בלוק הקוד הזה
- ה-`break` אומר ל-JavaScript לעצור ולצאת מה-switch
- אם אין התאמה, הוא מריץ את בלוק ה-`default` (אם יש כזה)

```javascript
// Program using switch statement for day of week
let dayNumber = 2;
let dayName;

switch (dayNumber) {
  case 1:
    dayName = "Monday";
    break;
  case 2:
    dayName = "Tuesday";
    break;
  case 3:
    dayName = "Wednesday";
    break;
  default:
    dayName = "Unknown day";
    break;
}
console.log(`Today is ${dayName}`);
```

בדוגמה הזו, JavaScript רואה ש-`dayNumber` הוא `2`, מוצא את ה-`case 2` המתאים, מגדיר את `dayName` ל-"יום שלישי", ואז יוצא מה-switch. התוצאה? "היום יום שלישי" מוצגת בקונסול.

✅ בדקו את ההבנה שלכם לגבי הקוד הזה והקוד הבא על ידי הרצתם בקונסול של הדפדפן. שנו את הערכים של המשתנה a כדי לשנות את התוצאה של `console.log()`.

## אופרטורים לוגיים ובוליאנים

החלטות מורכבות דורשות לעיתים קרובות הערכת מספר תנאים בו-זמנית. כמו שאלגברה בוליאנית מאפשרת למתמטיקאים לשלב ביטויים לוגיים, תכנות מספק אופרטורים לוגיים לחיבור מספר תנאים בוליאניים.

אופרטורים אלו מאפשרים לוגיקה מותנית מתוחכמת על ידי שילוב הערכות פשוטות של true/false.

| סימן | תיאור                                                                                     | דוגמה                                                                 |
| ------ | ----------------------------------------------------------------------------------------------- | ----------------------------------------------------------------------- |
| `&&`   | **וגם לוגי**: משווה שני ביטויים בוליאניים. מחזיר true **רק** אם שני הצדדים נכונים | `(5 > 3) && (5 < 10) // שני הצדדים נכונים. מחזיר true` |
| `\|\|` | **או לוגי**: משווה שני ביטויים בוליאניים. מחזיר true אם לפחות צד אחד נכון     | `(5 > 10) \|\| (5 < 10) // צד אחד שגוי, השני נכון. מחזיר true` |
| `!`    | **לא לוגי**: מחזיר את הערך ההפוך של ביטוי בוליאני                             | `!(5 > 10) // 5 לא גדול מ-10, אז "!" הופך את זה לנכון`         |

אופרטורים אלו מאפשרים לכם לשלב תנאים בדרכים שימושיות:
- וגם (`&&`) אומר ששני התנאים חייבים להיות נכונים
- או (`||`) אומר שלפחות תנאי אחד חייב להיות נכון  
- לא (`!`) הופך נכון לשגוי (ולהיפך)

## תנאים והחלטות עם אופרטורים לוגיים

בואו נראה את האופרטורים הלוגיים בפעולה עם דוגמה מציאותית יותר:

```javascript
let currentMoney = 600;
let laptopPrice = 800;
let laptopDiscountPrice = laptopPrice - (laptopPrice * 0.2); // Laptop price at 20 percent off

if (currentMoney >= laptopPrice || currentMoney >= laptopDiscountPrice) {
  // Condition is true. Code in this block will run.
  console.log("Getting a new laptop!");
} else {
  // Condition is false. Code in this block will run.
  console.log("Can't afford a new laptop, yet!");
}
```

בדוגמה הזו: אנחנו מחשבים מחיר הנחה של 20% (640), ואז מעריכים אם הכסף הזמין שלנו מכסה את המחיר המלא או את המחיר המוזל. מכיוון ש-600 עומד בסף המחיר המוזל של 640, התנאי מוערך כנכון.

### אופרטור שלילה

לפעמים קל יותר לחשוב על מצב שבו משהו **לא** נכון. כמו במקום לשאול "האם המשתמש מחובר?", אולי תרצו לשאול "האם המשתמש **לא** מחובר?" אופרטור סימן הקריאה (`!`) הופך את הלוגיקה עבורכם.

```javascript
if (!condition) {
  // runs if condition is false
} else {
  // runs if condition is true
}
```

אופרטור `!` הוא כמו לומר "ההפך מ..." – אם משהו הוא `true`, `!` הופך אותו ל-`false`, ולהיפך.

### ביטויים טרנריים

לצורך הקצאות מותנות פשוטות, JavaScript מספק את **האופרטור הטרנרי**. תחביר תמציתי זה מאפשר לכם לכתוב ביטוי מותנה בשורה אחת, שימושי כשאתם צריכים להקצות אחד משני ערכים בהתבסס על תנאי.

```javascript
let variable = condition ? returnThisIfTrue : returnThisIfFalse;
```

זה נקרא כמו שאלה: "האם התנאי הזה נכון? אם כן, השתמש בערך הזה. אם לא, השתמש בערך ההוא."

להלן דוגמה מוחשית יותר:

```javascript
let firstNumber = 20;
let secondNumber = 10;
let biggestNumber = firstNumber > secondNumber ? firstNumber : secondNumber;
```

✅ הקדישו דקה לקרוא את הקוד הזה כמה פעמים. האם אתם מבינים איך האופרטורים הללו עובדים?

הנה מה שהשורה הזו אומרת: "האם `firstNumber` גדול מ-`secondNumber`? אם כן, שים את `firstNumber` ב-`biggestNumber`. אם לא, שים את `secondNumber` ב-`biggestNumber`."

האופרטור הטרנרי הוא פשוט דרך קצרה יותר לכתוב את הצהרת ה-`if..else` המסורתית:

```javascript
let biggestNumber;
if (firstNumber > secondNumber) {
  biggestNumber = firstNumber;
} else {
  biggestNumber = secondNumber;
}
```

שתי הגישות מניבות תוצאות זהות. האופרטור הטרנרי מציע תמציתיות, בעוד שהמבנה המסורתי של if-else עשוי להיות קריא יותר עבור תנאים מורכבים.

---

## 🚀 אתגר

צרו תוכנית שנכתבת תחילה עם אופרטורים לוגיים, ואז כתבו אותה מחדש באמצעות ביטוי טרנרי. מה התחביר המועדף עליכם?

---

## אתגר סוכן GitHub Copilot 🚀

השתמשו במצב סוכן כדי להשלים את האתגר הבא:

**תיאור:** צרו מחשבון ציונים מקיף שמדגים מושגים שונים של קבלת החלטות מהשיעור הזה, כולל הצהרות if-else, הצהרות switch, אופרטורים לוגיים וביטויים טרנריים.

**הנחיה:** כתבו תוכנית JavaScript שמקבלת את הציון המספרי של תלמיד (0-100) וקובעת את הציון האותי שלו לפי הקריטריונים הבאים:
- A: 90-100
- B: 80-89  
- C: 70-79
- D: 60-69
- F: מתחת ל-60

דרישות:
1. השתמשו בהצהרת if-else כדי לקבוע את הציון האותי
2. השתמשו באופרטורים לוגיים כדי לבדוק אם התלמיד עבר (ציון >= 60) וגם קיבל הצטיינות (ציון >= 90)
3. השתמשו בהצהרת switch כדי לספק משוב ספציפי לכל ציון אותי
4. השתמשו באופרטור טרנרי כדי לקבוע אם התלמיד זכאי לקורס הבא (ציון >= 70)
5. כללו בדיקת קלט כדי לוודא שהציון נמצא בין 0 ל-100

בדקו את התוכנית שלכם עם ציונים שונים כולל מקרים גבוליים כמו 59, 60, 89, 90 וקלטים לא חוקיים.

למדו עוד על [מצב סוכן](https://code.visualstudio.com/blogs/2025/02/24/introducing-copilot-agent-mode) כאן.

## שאלון לאחר השיעור

[שאלון לאחר השיעור](https://ff-quizzes.netlify.app/web/quiz/12)

## סקירה ולימוד עצמי

קראו עוד על האופרטורים הרבים הזמינים למשתמש [ב-MDN](https://developer.mozilla.org/docs/Web/JavaScript/Reference/Operators).

עברו על [מדריך האופרטורים המופלא של ג'וש קומו](https://joshwcomeau.com/operator-lookup/)!

## משימה

[אופרטורים](assignment.md)

---

**הצהרת אחריות**:  
מסמך זה תורגם באמצעות שירות תרגום AI [Co-op Translator](https://github.com/Azure/co-op-translator). למרות שאנו שואפים לדיוק, יש לקחת בחשבון שתרגומים אוטומטיים עשויים להכיל שגיאות או אי דיוקים. המסמך המקורי בשפתו המקורית צריך להיחשב כמקור סמכותי. עבור מידע קריטי, מומלץ להשתמש בתרגום מקצועי אנושי. אנו לא נושאים באחריות לאי הבנות או לפרשנויות שגויות הנובעות משימוש בתרגום זה.