<!--
CO_OP_TRANSLATOR_METADATA:
{
  "original_hash": "060da99457217ba40910854009a11ae8",
  "translation_date": "2025-10-20T21:25:06+00:00",
  "source_file": "7-bank-project/1-template-route/README.md",
  "language_code": "mr"
}
-->
# बँकिंग अ‍ॅप तयार करा भाग 1: वेब अ‍ॅपमध्ये HTML टेम्पलेट्स आणि रूट्स

## व्याख्यानपूर्व प्रश्नमंजुषा

[व्याख्यानपूर्व प्रश्नमंजुषा](https://ff-quizzes.netlify.app/web/quiz/41)

### परिचय

ब्राउझरमध्ये जावास्क्रिप्ट आल्यापासून वेबसाइट्स पूर्वीपेक्षा अधिक परस्परसंवादी आणि जटिल होत आहेत. वेब तंत्रज्ञानाचा वापर आता पूर्णपणे कार्यक्षम अ‍ॅप्लिकेशन्स तयार करण्यासाठी केला जातो, जे थेट ब्राउझरमध्ये चालते आणि ज्याला आपण [वेब अ‍ॅप्लिकेशन्स](https://en.wikipedia.org/wiki/Web_application) म्हणतो. वेब अ‍ॅप्स अत्यंत परस्परसंवादी असल्यामुळे, वापरकर्त्यांना प्रत्येक क्रिया केल्यानंतर पूर्ण पृष्ठ पुन्हा लोड होण्याची वाट पाहायची इच्छा नसते. म्हणूनच, जावास्क्रिप्टचा वापर HTML थेट अपडेट करण्यासाठी केला जातो, ज्यामुळे वापरकर्त्याचा अनुभव अधिक गुळगुळीत होतो.

या धड्यात, आम्ही HTML टेम्पलेट्स वापरून बँक वेब अ‍ॅप तयार करण्यासाठी पाया घालणार आहोत, ज्यामुळे संपूर्ण HTML पृष्ठ पुन्हा लोड न करता अनेक स्क्रीन तयार करता येतील आणि अपडेट करता येतील.

### पूर्वतयारी

आपल्याला या धड्यात तयार होणाऱ्या वेब अ‍ॅपची चाचणी करण्यासाठी स्थानिक वेब सर्व्हरची आवश्यकता आहे. जर तुमच्याकडे नसल्यास, तुम्ही [Node.js](https://nodejs.org) इंस्टॉल करू शकता आणि तुमच्या प्रोजेक्ट फोल्डरमधून `npx lite-server` कमांड वापरू शकता. हे स्थानिक वेब सर्व्हर तयार करेल आणि तुमचे अ‍ॅप ब्राउझरमध्ये उघडेल.

### तयारी

तुमच्या संगणकावर `bank` नावाचा एक फोल्डर तयार करा आणि त्यात `index.html` नावाची फाइल ठेवा. आम्ही या HTML [बॉयलरप्लेट](https://en.wikipedia.org/wiki/Boilerplate_code) पासून सुरुवात करू:

```html
<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Bank App</title>
  </head>
  <body>
    <!-- This is where you'll work -->
  </body>
</html>
```

---

## HTML टेम्पलेट्स

जर तुम्हाला वेब पृष्ठासाठी अनेक स्क्रीन तयार करायच्या असतील, तर एक उपाय म्हणजे तुम्हाला प्रत्येक स्क्रीनसाठी एक HTML फाइल तयार करावी लागेल. परंतु, या उपायामध्ये काही अडचणी आहेत:

- स्क्रीन बदलताना तुम्हाला संपूर्ण HTML पुन्हा लोड करावी लागेल, ज्यामुळे वेळ लागतो.
- वेगवेगळ्या स्क्रीनमध्ये डेटा शेअर करणे कठीण होते.

दुसरा दृष्टिकोन म्हणजे एकच HTML फाइल असणे आणि `<template>` घटक वापरून अनेक [HTML टेम्पलेट्स](https://developer.mozilla.org/docs/Web/HTML/Element/template) परिभाषित करणे. टेम्पलेट म्हणजे पुनर्वापर करता येणारा HTML ब्लॉक आहे जो ब्राउझरद्वारे प्रदर्शित केला जात नाही आणि जावास्क्रिप्ट वापरून रनटाइमवर इंस्टंटेट करणे आवश्यक आहे.

### कार्य

आम्ही दोन स्क्रीनसह बँक अ‍ॅप तयार करू: लॉगिन पृष्ठ आणि डॅशबोर्ड. प्रथम, HTML बॉडीमध्ये एक प्लेसहोल्डर घटक जोडूया, ज्याचा वापर आम्ही आमच्या अ‍ॅपच्या वेगवेगळ्या स्क्रीन इंस्टंटेट करण्यासाठी करू:

```html
<div id="app">Loading...</div>
```

आम्ही त्याला `id` देत आहोत जेणेकरून नंतर जावास्क्रिप्टसह त्याला शोधणे सोपे होईल.

> टिप: या घटकाची सामग्री बदलली जाईल, त्यामुळे अ‍ॅप लोड होत असताना दर्शविण्यासाठी लोडिंग संदेश किंवा इंडिकेटर ठेवू शकतो.

यानंतर, HTML टेम्पलेट लॉगिन पृष्ठासाठी खाली जोडूया. सध्या आम्ही फक्त एक शीर्षक आणि एक विभाग ठेवू ज्यामध्ये नेव्हिगेशनसाठी वापरता येईल असा एक लिंक असेल.

```html
<template id="login">
  <h1>Bank App</h1>
  <section>
    <a href="/dashboard">Login</a>
  </section>
</template>
```

यानंतर, डॅशबोर्ड पृष्ठासाठी आणखी एक HTML टेम्पलेट जोडूया. या पृष्ठामध्ये वेगवेगळे विभाग असतील:

- शीर्षक आणि लॉगआउट लिंकसह हेडर
- बँक खात्याचा वर्तमान शिल्लक
- व्यवहारांची यादी, टेबलमध्ये प्रदर्शित केली जाईल

```html
<template id="dashboard">
  <header>
    <h1>Bank App</h1>
    <a href="/login">Logout</a>
  </header>
  <section>
    Balance: 100$
  </section>
  <section>
    <h2>Transactions</h2>
    <table>
      <thead>
        <tr>
          <th>Date</th>
          <th>Object</th>
          <th>Amount</th>
        </tr>
      </thead>
      <tbody></tbody>
    </table>
  </section>
</template>
```

> टिप: HTML टेम्पलेट्स तयार करताना, तुम्हाला ते कसे दिसेल हे पाहायचे असल्यास, तुम्ही `<template>` आणि `</template>` ओळी `<!-- -->` ने कॉमेंट करू शकता.

✅ तुमच्या मते, टेम्पलेट्सवर `id` गुणधर्म का वापरतो? तुम्ही वर्गांसारखे काहीतरी वापरू शकता का?

## जावास्क्रिप्टसह टेम्पलेट्स प्रदर्शित करणे

जर तुम्ही तुमची सध्याची HTML फाइल ब्राउझरमध्ये वापरली, तर तुम्हाला `Loading...` हेच दिसेल. कारण आम्हाला HTML टेम्पलेट्स इंस्टंटेट आणि प्रदर्शित करण्यासाठी काही जावास्क्रिप्ट कोड जोडण्याची आवश्यकता आहे.

टेम्पलेट इंस्टंटेट करणे सहसा 3 चरणांमध्ये केले जाते:

1. DOM मध्ये टेम्पलेट घटक शोधा, उदाहरणार्थ [`document.getElementById`](https://developer.mozilla.org/docs/Web/API/Document/getElementById) वापरून.
2. टेम्पलेट घटक क्लोन करा, [`cloneNode`](https://developer.mozilla.org/docs/Web/API/Node/cloneNode) वापरून.
3. ते दृश्यमान घटकाखाली DOM मध्ये जोडणे, उदाहरणार्थ [`appendChild`](https://developer.mozilla.org/docs/Web/API/Node/appendChild) वापरून.

✅ टेम्पलेट क्लोन करण्याची आवश्यकता का आहे? जर आपण हा टप्पा वगळला तर काय होईल?

### कार्य

तुमच्या प्रोजेक्ट फोल्डरमध्ये `app.js` नावाची नवीन फाइल तयार करा आणि ती HTML च्या `<head>` विभागात इम्पोर्ट करा:

```html
<script src="app.js" defer></script>
```

आता `app.js` मध्ये, आम्ही एक नवीन फंक्शन `updateRoute` तयार करू:

```js
function updateRoute(templateId) {
  const template = document.getElementById(templateId);
  const view = template.content.cloneNode(true);
  const app = document.getElementById('app');
  app.innerHTML = '';
  app.appendChild(view);
}
```

आम्ही येथे वर्णन केलेल्या 3 चरणांप्रमाणेच करतो. आम्ही `templateId` असलेल्या टेम्पलेटला इंस्टंटेट करतो आणि त्याच्या क्लोन केलेल्या सामग्रीला आमच्या अ‍ॅप प्लेसहोल्डरमध्ये ठेवतो. लक्षात घ्या की आम्हाला संपूर्ण टेम्पलेट सबट्री कॉपी करण्यासाठी `cloneNode(true)` वापरणे आवश्यक आहे.

आता या फंक्शनला एका टेम्पलेटसह कॉल करा आणि परिणाम पहा.

```js
updateRoute('login');
```

✅ या कोडचा उद्देश काय आहे `app.innerHTML = '';`? त्याशिवाय काय होईल?

## रूट्स तयार करणे

वेब अ‍ॅपबद्दल बोलताना, आम्ही **URL** ला विशिष्ट स्क्रीनशी नकाशा जोडण्याच्या हेतूला *रूटिंग* म्हणतो. अनेक HTML फाइल्स असलेल्या वेबसाइटवर, हे स्वयंचलितपणे केले जाते कारण फाइल पथ URL मध्ये प्रतिबिंबित होतात. उदाहरणार्थ, तुमच्या प्रोजेक्ट फोल्डरमध्ये या फाइल्ससह:

```
mywebsite/index.html
mywebsite/login.html
mywebsite/admin/index.html
```

जर तुम्ही `mywebsite` ला रूट म्हणून वेब सर्व्हर तयार केला, तर URL मॅपिंग असेल:

```
https://site.com            --> mywebsite/index.html
https://site.com/login.html --> mywebsite/login.html
https://site.com/admin/     --> mywebsite/admin/index.html
```

तथापि, आमच्या वेब अ‍ॅपसाठी आम्ही सर्व स्क्रीन असलेली एकच HTML फाइल वापरत आहोत, त्यामुळे ही डीफॉल्ट वागणूक आपल्याला मदत करणार नाही. आम्हाला हा नकाशा मॅन्युअली तयार करावा लागेल आणि जावास्क्रिप्ट वापरून प्रदर्शित टेम्पलेट अपडेट करावे लागेल.

### कार्य

आम्ही URL पथ आणि आमच्या टेम्पलेट्स दरम्यान [नकाशा](https://en.wikipedia.org/wiki/Associative_array) लागू करण्यासाठी एक साधा ऑब्जेक्ट वापरू. तुमच्या `app.js` फाइलच्या शीर्षस्थानी हा ऑब्जेक्ट जोडा.

```js
const routes = {
  '/login': { templateId: 'login' },
  '/dashboard': { templateId: 'dashboard' },
};
```

आता `updateRoute` फंक्शन थोडे बदलूया. `templateId` थेट आर्ग्युमेंट म्हणून पास करण्याऐवजी, आम्हाला प्रथम सध्याच्या URL कडे पाहून ते शोधायचे आहे आणि नंतर आमच्या नकाशाचा वापर करून संबंधित टेम्पलेट ID मूल्य मिळवायचे आहे. आम्ही [`window.location.pathname`](https://developer.mozilla.org/docs/Web/API/Location/pathname) वापरून URL मधील फक्त पथ विभाग मिळवू शकतो.

```js
function updateRoute() {
  const path = window.location.pathname;
  const route = routes[path];

  const template = document.getElementById(route.templateId);
  const view = template.content.cloneNode(true);
  const app = document.getElementById('app');
  app.innerHTML = '';
  app.appendChild(view);
}
```

येथे आम्ही घोषित केलेल्या रूट्सला संबंधित टेम्पलेटशी नकाशा जोडले. तुम्ही तुमच्या ब्राउझरमध्ये URL मॅन्युअली बदलून ते योग्य प्रकारे कार्य करते का ते तपासू शकता.

✅ जर तुम्ही URL मध्ये अज्ञात पथ प्रविष्ट केला तर काय होईल? आपण हे कसे सोडवू शकतो?

## नेव्हिगेशन जोडणे

आमच्या अ‍ॅपसाठी पुढील पाऊल म्हणजे पृष्ठांमध्ये नेव्हिगेट करण्याची शक्यता जोडणे, URL मॅन्युअली बदलण्याची आवश्यकता न ठेवता. याचा अर्थ दोन गोष्टी:

1. सध्याचा URL अपडेट करणे
2. नवीन URL वर आधारित प्रदर्शित टेम्पलेट अपडेट करणे

आम्ही `updateRoute` फंक्शनसह दुसऱ्या भागाची आधीच काळजी घेतली आहे, त्यामुळे आम्हाला सध्याचा URL कसा अपडेट करायचा ते शोधावे लागेल.

आम्हाला जावास्क्रिप्ट वापरावी लागेल आणि विशेषतः [`history.pushState`](https://developer.mozilla.org/docs/Web/API/History/pushState) वापरावे लागेल, ज्यामुळे URL अपडेट करणे आणि ब्राउझिंग इतिहासात नवीन एंट्री तयार करणे शक्य होते, HTML पुन्हा लोड न करता.

> नोट: HTML अँकर घटक [`<a href>`](https://developer.mozilla.org/docs/Web/HTML/Element/a) स्वतःहून वेगवेगळ्या URL वर हायपरलिंक्स तयार करण्यासाठी वापरला जाऊ शकतो, परंतु तो डीफॉल्टनुसार HTML पुन्हा लोड करतो. कस्टम जावास्क्रिप्टसह रूटिंग हाताळताना, क्लिक इव्हेंटवर `preventDefault()` फंक्शन वापरून हे वर्तन टाळणे आवश्यक आहे.

### कार्य

आमच्या अ‍ॅपमध्ये नेव्हिगेट करण्यासाठी वापरता येईल असे नवीन फंक्शन तयार करूया:

```js
function navigate(path) {
  window.history.pushState({}, path, path);
  updateRoute();
}
```

हे मेथड दिलेल्या पथावर आधारित सध्याचा URL प्रथम अपडेट करते, नंतर टेम्पलेट अपडेट करते. `window.location.origin` प्रॉपर्टी URL रूट परत करते, ज्यामुळे आम्हाला दिलेल्या पथावरून पूर्ण URL पुन्हा तयार करता येतो.

आता आमच्याकडे हे फंक्शन आहे, आम्ही एक समस्या सोडवू शकतो जी आपल्याला वाटते की जर पथ कोणत्याही परिभाषित रूटशी जुळत नसेल. आम्ही `updateRoute` फंक्शन थोडे बदलून एक फॉलबॅक जोडू जेव्हा आम्हाला जुळणारा रूट सापडत नाही.

```js
function updateRoute() {
  const path = window.location.pathname;
  const route = routes[path];

  if (!route) {
    return navigate('/login');
  }

  ...
```

जर रूट सापडला नाही, तर आम्ही आता `login` पृष्ठावर पुनर्निर्देशित करू.

आता एक फंक्शन तयार करू जेव्हा लिंक क्लिक केली जाते तेव्हा URL मिळवण्यासाठी आणि ब्राउझरच्या डीफॉल्ट लिंक वर्तन टाळण्यासाठी:

```js
function onLinkClick(event) {
  event.preventDefault();
  navigate(event.target.href);
}
```

आमच्या नेव्हिगेशन सिस्टमला पूर्ण करण्यासाठी, HTML मधील *लॉगिन* आणि *लॉगआउट* लिंकसाठी बाइंडिंग्ज जोडूया.

```html
<a href="/dashboard" onclick="onLinkClick(event)">Login</a>
...
<a href="/login" onclick="onLinkClick(event)">Logout</a>
```

वरील `event` ऑब्जेक्ट, `click` इव्हेंट कॅप्चर करते आणि आमच्या `onLinkClick` फंक्शनला पास करते.

[`onclick`](https://developer.mozilla.org/docs/Web/API/GlobalEventHandlers/onclick) गुणधर्म वापरून, `click` इव्हेंट जावास्क्रिप्ट कोडशी बाइंड करा, येथे `navigate()` फंक्शन कॉल.

या लिंकवर क्लिक करून पहा, तुम्ही आता तुमच्या अ‍ॅपच्या वेगवेगळ्या स्क्रीनमध्ये नेव्हिगेट करू शकता.

✅ `history.pushState` मेथड HTML5 मानकाचा भाग आहे आणि [सर्व आधुनिक ब्राउझरमध्ये](https://caniuse.com/?search=pushState) लागू केली गेली आहे. जर तुम्ही जुन्या ब्राउझरसाठी वेब अ‍ॅप तयार करत असाल, तर तुम्ही या API च्या जागी एक युक्ती वापरू शकता: पथाच्या आधी [हॅश (`#`)](https://en.wikipedia.org/wiki/URI_fragment) वापरून तुम्ही रूटिंग लागू करू शकता जे नियमित अँकर नेव्हिगेशनसह कार्य करते आणि पृष्ठ पुन्हा लोड करत नाही, कारण त्याचा उद्देश पृष्ठामध्ये अंतर्गत लिंक तयार करणे होता.

## ब्राउझरच्या बॅक आणि फॉरवर्ड बटन्स हाताळणे

`history.pushState` वापरल्याने ब्राउझरच्या नेव्हिगेशन इतिहासात नवीन एंट्री तयार होतात. तुम्ही तुमच्या ब्राउझरचा *बॅक बटण* दाबून तपासू शकता, त्यात असे काहीतरी दिसेल:

![नेव्हिगेशन इतिहासाचा स्क्रीनशॉट](../../../../translated_images/history.7fdabbafa521e06455b738d3dafa3ff41d3071deae60ead8c7e0844b9ed987d8.mr.png)

जर तुम्ही बॅक बटणावर काही वेळा क्लिक केले, तर तुम्हाला दिसेल की सध्याचा URL बदलतो आणि इतिहास अपडेट होतो, परंतु समान टेम्पलेट प्रदर्शित होत राहते.

कारण अ‍ॅप्लिकेशनला माहित नाही की इतिहास बदलला की प्रत्येक वेळी `updateRoute()` कॉल करणे आवश्यक आहे. जर तुम्ही [`history.pushState`](https://developer.mozilla.org/docs/Web/API/History/pushState) दस्तऐवज पाहिला, तर तुम्हाला दिसेल की जर स्टेट बदलला - म्हणजे आपण वेगळ्या URL वर गेलो - तर [`popstate`](https://developer.mozilla.org/docs/Web/API/Window/popstate_event) इव्हेंट ट्रिगर होतो. आम्ही ही समस्या सोडवण्यासाठी त्याचा वापर करू.

### कार्य

ब्राउझर इतिहास बदलल्यावर प्रदर्शित टेम्पलेट अपडेट होईल याची खात्री करण्यासाठी, आम्ही एक नवीन फंक्शन जोडू जे `updateRoute()` कॉल करेल. आम्ही ते आमच्या `app.js` फाइलच्या तळाशी जोडू:

```js
window.onpopstate = () => updateRoute();
updateRoute();
```

> नोट: आम्ही येथे आमच्या `popstate` इव्हेंट हँडलर घोषित करण्यासाठी [अ‍ॅरो फंक्शन](https://developer.mozilla.org/docs/Web/JavaScript/Reference/Functions/Arrow_functions) वापरले आहे, परंतु एक नियमित फंक्शन देखील त्याचप्रमाणे कार्य करेल.

अ‍ॅरो फंक्शन्सवर एक रिफ्रेशर व्हिडिओ येथे आहे:

[![अ‍ॅरो फंक्शन्स](https://img.youtube.com/vi/OP6eEbOj2sc/0.jpg)](https://youtube.com/watch?v=OP6eEbOj2sc "अ‍ॅरो फंक्शन्स")

> 🎥 अ‍ॅरो फंक्शन्सबद्दल व्हिडिओसाठी वरील प्रतिमेवर क्लिक करा.

आता तुमच्या ब्राउझरचे बॅक आणि फॉरवर्ड बटन्स वापरून पहा आणि यावेळी प्रदर्शित रूट योग्य प्रकारे अपडेट होत आहे का ते तपासा.

---

## GitHub Copilot Agent चॅलेंज 🚀

Agent मोड वापरून खालील चॅलेंज पूर्ण करा:

**वर्णन:** बँकिंग अ‍ॅप सुधारित करा, त्रुटी हाताळणी आणि अवैध रूट्ससाठी 404 पृष्ठ टेम्पलेट लागू करून, अस्तित्वात नसलेल्या पृष्ठांवर नेव्हिगेट करताना वापरकर्त्याचा अनुभव सुधारित करा.

**प्रॉम्प्ट:** "not-found" id असलेले नवीन HTML टेम्पलेट तयार करा जे स्टायलिंगसह वापरकर्त्यासाठी अनुकूल 404 त्रुटी पृष्ठ प्रदर्शित करते. नंतर जावास्क्रिप्ट रूटिंग लॉजिक सुधारित करा जेव्हा वापरकर्ते अवैध URL वर नेव्हिगेट करतात तेव्हा हे टेम्पलेट दर्शवते आणि "Go Home" बटण जोडा जो लॉगिन पृष्ठावर परत नेव्हिगेट करतो.

## 🚀 चॅलेंज

या अ‍ॅपसाठी क्रेडिट्स दर्शवणाऱ्या तिसऱ्या पृष्ठासाठी नवीन टेम्पलेट आणि रूट जोडा.

## व्याख्यानोत्तर प्रश्नमंजुषा

[व्याख्यानोत्तर प्रश्नमंजुषा](https://ff-quizzes.netlify.app/web/quiz/42)

## पुनरावलोकन आणि स्व-अभ्यास

वेब डेव्हलपमेंटमधील रूटिंग हे आश्चर्यकारकपणे कठीण भागांपैकी एक आहे, विशेषतः वेब पृष्ठ रीफ्रेश वर्तनातून सिंगल पृष्ठ अ‍ॅप्लिकेशन पृष्ठ रीफ्रेशेसकडे जात आहे. [Azure Static Web App सेवा](https://docs.microsoft.com/azure/static-web-apps/routes/?WT.mc_id=academic-77807-sagibbon) रूटिंग कसे हाताळते याबद्दल थोडे वाचा. तुम्ही त्या दस्तऐवजात वर्णन केलेल्या काही निर्णयांची आवश्यकता का आहे हे स्पष्ट करू शकता का?

## असाइनमेंट

[रूटिंग सुधारित करा](assignment.md)

---

**अस्वीकरण**:  
हा दस्तऐवज AI भाषांतर सेवा [Co-op Translator](https://github.com/Azure/co-op-translator) वापरून भाषांतरित करण्यात आला आहे. आम्ही अचूकतेसाठी प्रयत्नशील असलो तरी, कृपयास लक्षात ठेवा की स्वयंचलित भाषांतरे त्रुटी किंवा अचूकतेच्या अभावासह असू शकतात. मूळ भाषेतील दस्तऐवज हा अधिकृत स्रोत मानला जावा. महत्त्वाच्या माहितीसाठी, व्यावसायिक मानवी भाषांतराची शिफारस केली जाते. या भाषांतराचा वापर करून उद्भवलेल्या कोणत्याही गैरसमज किंवा चुकीच्या अर्थासाठी आम्ही जबाबदार राहणार नाही.